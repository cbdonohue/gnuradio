<%
    namespace = header_info['namespace']
    modname = header_info['module_name']
    classes=header_info['classes']
    free_functions=header_info['free_functions']
%>

${license}

/* This file is automatically generated using the gen_nonblock_bindings.py tool */

#ifndef INCLUDED_${'_'.join(namespace).upper()}_${basename.upper()}_PYTHON_HPP
#define INCLUDED_${'_'.join(namespace).upper()}_${basename.upper()}_PYTHON_HPP

#include <${prefix_include_root}/${basename}.h>

void bind_${basename}(py::module& m)
{
% for cls in classes:
% if classes:
    using ${cls['name']}    = ${"::".join(namespace)}::${cls['name']};
% endif ##classes
% endfor ##classes
% for cls in classes:

<%
try:
        member_functions = cls['member_functions']
except:
        member_functions = []
try:
        constructors = cls['constructors']
except:
        constructors = []
%>
    py::class_<${cls['name']}, std::shared_ptr<${cls['name']}>>(m, "${cls['name']}")
% for fcn in constructors:
<%
fcn_args = fcn['arguments']
%>\
% if len(fcn_args) == 0:
        .def(py::init<>())
%else:
        .def(py::init<\
% for arg in fcn_args:
${arg['dtype']}${'>(),' if loop.index == len(fcn['arguments'])-1 else ',' }\
% endfor ## args

% for arg in fcn_args:
           py::arg("${arg['name']}")${" = " + arg['default'] if arg['default'] else ''}${'' if loop.index == len(fcn['arguments'])-1 else ',' } 
% endfor
        )
% endif
% endfor ## constructors
% for fcn in member_functions:
<%
fcn_args = fcn['arguments']
%>\
% if len(fcn_args) == 0:
        .def("${fcn['name']}",&${cls['name']}::${fcn['name']})
%else:
        .def("${fcn['name']}",&${cls['name']}::${fcn['name']},
% for arg in fcn_args:
            py::arg("${arg['name']}")${" = " + arg['default'] if arg['default'] else ''}${'' if loop.index == len(fcn['arguments'])-1 else ',' } 
% endfor ## args
        )
% endif
% endfor ## member_functions
        ;
% endfor ## classes

% if free_functions:
% for fcn in free_functions:
<%
fcn_args = fcn['arguments']
fcn_name = fcn['name']
matcher = lambda x,name: x['name'] == name
overloaded = sum([matcher(f,fcn_name) for f in free_functions]) > 1
## if overloaded:
## void (block_detail::*)(std::vector<gr::tag_t>&,
##                                      unsigned int,
##                                      uint64_t,
##                                      uint64_t,
##                                      const pmt::pmt_t&,
##                                      long))
##     overloaded_str = 'void (block_detail::*)(std::vector<gr::tag_t>&,
##                                      unsigned int,
##                                      uint64_t,
##                                      uint64_t,
##                                      const pmt::pmt_t&,
##                                      long))
## Need to put the return type in the json
%>\
% if len(fcn_args) == 0:
    m.def("${fcn['name']}",&${'::'.join(namespace)}::${fcn['name']});
%else:
    m.def("${fcn['name']}",&${'::'.join(namespace)}::${fcn['name']},
% for arg in fcn_args:
        py::arg("${arg['name']}")${" = " + arg['default'] if arg['default'] else ''}${'' if loop.index == len(fcn['arguments'])-1 else ',' } 
% endfor
    );
% endif
% endfor
% endif ## free_functions
} 

#endif /* INCLUDED_${'_'.join(namespace).upper()}_${basename.upper()}_PYTHON_HPP */
