{"module_name": "digital", "namespace": ["gr", "digital"], "class": "symbol_sync_cc", "block_type": "block", "io_signature": {"input": {"signature": "make", "min_streams": "1", "max_streams": "1", "sizeof_stream_item": "sizeof(gr_complex)"}, "output": {"signature": "makev", "min_streams": "1", "max_streams": "4", "sizeof_stream_items": "std::vector<int>(4)"}}, "message_port": {"input": [], "output": []}, "make": {"arguments": [{"name": "detector_type", "dtype": "gr::digital::ted_type", "default": null}, {"name": "sps", "dtype": "float", "default": null}, {"name": "loop_bw", "dtype": "float", "default": null}, {"name": "damping_factor", "dtype": "float", "default": "1.F"}, {"name": "ted_gain", "dtype": "float", "default": "1.F"}, {"name": "max_deviation", "dtype": "float", "default": "1.5F"}, {"name": "osps", "dtype": "int", "default": "1"}, {"name": "slicer", "dtype": "gr::digital::constellation_sptr", "default": "gr::digital::constellation_sptr()"}, {"name": "interp_type", "dtype": "gr::digital::ir_type", "default": "::gr::digital::ir_type::IR_MMSE_8TAP"}, {"name": "n_filters", "dtype": "int", "default": "128"}, {"name": "taps", "dtype": "std::vector<float, std::allocator<float> > const &", "default": "std::vector<float>()"}]}, "methods": [{"name": "set_loop_bandwidth", "arguments_type": [{"name": "omega_n_norm", "dtype": "float"}]}, {"name": "set_damping_factor", "arguments_type": [{"name": "zeta", "dtype": "float"}]}, {"name": "set_ted_gain", "arguments_type": [{"name": "ted_gain", "dtype": "float"}]}, {"name": "set_alpha", "arguments_type": [{"name": "alpha", "dtype": "float"}]}, {"name": "set_beta", "arguments_type": [{"name": "beta", "dtype": "float"}]}], "properties": [{"name": "loop_bandwidth", "dtype": "float", "read_only": true}, {"name": "damping_factor", "dtype": "float", "read_only": true}, {"name": "ted_gain", "dtype": "float", "read_only": false}, {"name": "alpha", "dtype": "float", "read_only": false}, {"name": "beta", "dtype": "float", "read_only": false}], "docstring": ["/*!\n * \\brief Symbol Synchronizer block with complex input, complex output.\n * \\ingroup synchronizers_blk\n *\n * \\details\n * This implements a discrete-time error-tracking synchronizer.\n *\n * For this block to work properly, the input stream must meet the\n * following requirements:\n *\n * 1. if not using the PFB Matched Filter interpolator, and using\n * a non-CPM timing error detector, the input pulses must have peaks\n * (not flat), which usually can be implemented by using a matched\n * filter before this block.\n *\n * 2. for decision directed timing error detectors, the input pulses\n * should nominally match the normalized slicer constellation, which\n * is normalized to an average symbol magnitude of 1.0 over the entire\n * constellation.\n */", "// gr::digital::symbol_sync_cc::sptr", "/*!\n     * Make a Symbol Synchronizer block.\n     *\n     * \\details\n     * This implements a discrete-time error-tracking synchronizer.\n     *\n     * For this block to work properly, the input stream must meet the\n     * following requirements:\n     *\n     * 1. if not using the PFB Matched Filter interpolator, and using\n     * a non-CPM timing error detector, the input pulses must have peaks\n     * (not flat), which usually can be implemented by using a matched\n     * filter before this block.\n     *\n     * 2. for decision directed timing error detectors, the input pulses\n     * should nominally match the normalized slicer constellation, which\n     * is normalized to an average symbol magnitude of 1.0 over the entire\n     * constellation.\n     *\n     * \\param detector_type\n     * The enumerated type of timing error detector to use.\n     * See enum ted_type for a list of possible types.\n     *\n     * \\param sps\n     * User specified nominal clock period in samples per symbol.\n     *\n     * \\param loop_bw\n     * Approximate normailzed loop bandwidth of the symbol clock tracking\n     * loop. It should nominally be close to 0, but greater than 0.  If\n     * unsure, start with a number around 2*pi*0.040, and experiment to find\n     * the value that works best for your situation.\n     *\n     * \\param damping_factor\n     * Damping factor of the symbol clock tracking loop.\n     * Damping < 1.0f is an under-damped loop.\n     * Damping = 1.0f/sqrt(2.0f) is a maximally flat loop response.\n     * Damping = 1.0f is a critically-damped loop.\n     * Damping > 1.0f is an over-damped loop.\n     *\n     * \\param ted_gain\n     * Expected gain of the timing error detector, given the TED in use\n     * and the anticipated input amplitude, pulse shape, and Es/No.\n     * This value is the slope of the TED's S-curve at timing offset tau = 0.\n     * This value is normally computed by the user analytically or by\n     * simulation in a tool outside of GNURadio.\n     * This value must be correct for the loop filter gains to be computed\n     * properly from the desired input loop bandwidth and damping factor.\n     *\n     * \\param max_deviation\n     * Maximum absolute deviation of the average clock period estimate\n     * from the user specified nominal clock period in samples per symbol.\n     *\n     * \\param osps\n     * The number of output samples per symbol (default=1).\n     *\n     * \\param slicer\n     * A constellation obj shared pointer that will be used by\n     * decision directed timing error detectors to make decisions.\n     * I.e. the timing error detector will use this constellation\n     * as a slicer, if the particular algorithm needs sliced\n     * symbols.\n     *\n     * \\param interp_type\n     * The enumerated type of interpolating resampler to use.\n     * See the interpolating resampler type enum for a list of possible types.\n     *\n     * \\param n_filters\n     * The number of arms in the polyphase filterbank of the interpolating\n     * resampler, if using an interpolating resampler that uses a PFB.\n     *\n     * \\param taps\n     * The prototype filter for the polyphase filterbank of the interpolating\n     * resampler, if using an interpolating resampler that uses a PFB.\n     */", "/*!\n     * \\brief Returns the normalized approximate loop bandwidth.\n     *\n     * \\details\n     * See the documentation for set_loop_bandwidth() for more details.\n     *\n     * Note that if set_alpha() or set_beta() were called to directly\n     * set gains, the value returned by this method will be inaccurate/stale.\n     */", "/*!\n     * \\brief Returns the loop damping factor.\n     *\n     * \\details\n     * See the documentation for set_damping_factor() for more details.\n     *\n     * Note that if set_alpha() or set_beta() were called to directly\n     * set gains, the value returned by this method will be inaccurate/stale.\n     */", "/*!\n     * \\brief Returns the user provided expected gain of the Timing Error\n     * Detector.\n     *\n     * \\details\n     * See the documentation for set_ted_gain() for more details.\n     */", "/*!\n     * \\brief Returns the PI filter proportional gain, alpha.\n     *\n     * \\details\n     * See the documentation for set_alpha() for more details.\n     */", "/*!\n     * \\brief Returns the PI filter integral gain, beta.\n     *\n     * \\details\n     * See the documentation for set_beta() for more details.\n     */", "/*!\n     * \\brief Set the normalized approximate loop bandwidth.\n     *\n     * \\details\n     * Set the normalized approximate loop bandwidth.\n     * Useful values are usually close to 0.0, e.g. 2*pi*0.045.\n     *\n     * It should be a small positive number, corresponding to the normalized\n     * natural radian frequency of the loop as digital low-pass filter that is\n     * filtering the clock phase/timing error.\n     *\n     * Technically this parameter corresponds to the natural radian frequency\n     * of the 2nd order loop transfer function (scaled by Fs),\n     * which is the radius of the pole locations in the s-plane of an\n     * underdamped analog 2nd order system.\n     *\n     * The input parameter corresponds to omega_n_norm in the following\n     * relation:\n     *\n     *     omega_n_norm = omega_n*T = 2*pi*f_n*T = 2*pi*f_n_norm\n     *\n     * where T is the period of the clock being estimated by this\n     * clock tracking loop, and omega_n is the natural radian frequency\n     * of the 2nd order loop transfer function.\n     *\n     * When a new loop bandwidth is set, the gains, alpha and beta,\n     * of the loop are automatically recalculated.\n     *\n     * \\param omega_n_norm    normalized approximate loop bandwidth\n     */", "/*!\n     * \\brief Set the loop damping factor.\n     *\n     * \\details\n     * Set the damping factor of the loop.\n     * Damping in the range (0.0, 1.0) yields an under-damped loop.\n     * Damping in the range (1.0, Inf) yields an over-damped loop.\n     * Damping equal to 1.0 yields a crtically-damped loop.\n     * Damping equal to 1.0/sqrt(2.0) yields a maximally flat\n     * loop filter response.\n     *\n     * Damping factor of the 2nd order loop transfer function.\n     * When a new damping factor is set, the gains, alpha and beta,\n     * of the loop are automatcally recalculated.\n     *\n     * \\param zeta    loop damping factor\n     */", "/*!\n     * \\brief Set the expected gain of the Timing Error Detector.\n     *\n     * \\details\n     * Sets the expected gain of the timing error detector, given the TED in\n     * use and the anticipated input amplitude, pulse shape, and Es/No.\n     * This value is the slope of the TED's S-curve at timing offset tau = 0.\n     * This value is normally computed by the user analytically or by\n     * simulation in a tool outside of GNURadio.\n     * This value must be correct for the loop filter gains to be computed\n     * properly from the desired input loop bandwidth and damping factor.\n     *\n     * When a new ted_gain is set, the gains, alpha and beta,\n     * of the loop are automatcally recalculated.\n     *\n     * \\param ted_gain    expected gain of the timing error detector\n     */", "/*!\n     * \\brief Set the PI filter proportional gain, alpha.\n     *\n     * \\details\n     * Sets the PI filter proportional gain, alpha.\n     * This gain directly mutliplies the clock phase/timing error\n     * term in the PI filter when advancing the loop.\n     * It most directly affects the instantaneous clock period estimate,\n     * T_inst, and instantaneous clock phase estimate, tau.\n     *\n     * This value would normally be adjusted by setting the loop\n     * bandwidth and damping factor. However,\n     * it can be set here directly if desired.\n     *\n     * Setting this parameter directly is probably only feasible if\n     * the user is directly observing the estimates of average clock\n     * period and instantaneous clock period over time in response to\n     * an impulsive change in the input stream (i.e. watching the loop\n     * transient behavior at the start of a data burst).\n     *\n     * \\param alpha    PI filter proportional gain\n     */", "/*!\n     * \\brief Set the PI filter integral gain, beta.\n     *\n     * \\details\n     * Sets the PI filter integral gain, beta.\n     * This gain is used when integrating the clock phase/timing error\n     * term in the PI filter when advancing the loop.\n     * It most directly affects the average clock period estimate,\n     * T_avg.\n     *\n     * This value would normally be adjusted by setting the loop\n     * bandwidth and damping factor. However,\n     * it can be set here directly if desired.\n     *\n     * Setting this parameter directly is probably only feasible if\n     * the user is directly observing the estimates of average clock\n     * period and instantaneous clock period over time in response to\n     * an impulsive change in the input stream (i.e. watching the loop\n     * transient behavior at the start of a data burst).\n     *\n     * \\param beta    PI filter integral gain\n     */", "/* namespace digital */", "/* namespace gr */", "/* INCLUDED_DIGITAL_SYMBOL_SYNC_CC_H */"]}